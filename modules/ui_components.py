"""
Module d'interface utilisateur pour JBW Viewer
==============================================

Ce module g√®re l'interface utilisateur Tkinter de l'application desktop.

Auteur: Assistant IA
Date: 2025
Version: 1.0
"""

import tkinter as tk
from tkinter import ttk, messagebox, filedialog
import webbrowser
import os
from typing import Callable
from .data_manager import DataManager
from .map_generator import MapGenerator


class JBWViewerUI:
    """
    Interface utilisateur principale de l'application JBW Viewer.
    
    Cette classe g√®re :
    - L'interface Tkinter principale
    - Les contr√¥les utilisateur (boutons, champs de saisie)
    - L'interaction avec les modules de donn√©es et cartes
    """
    
    def __init__(self):
        """
        Initialise l'interface utilisateur.
        """
        self.root = tk.Tk()
        self.data_manager = None
        self.map_generator = None
        self.setup_ui()
        
        # Charger automatiquement les donn√©es au d√©marrage
        self.auto_load_data()
    
    def auto_load_data(self) -> None:
        """
        Charge automatiquement les donn√©es au d√©marrage de l'application.
        """
        try:
            self.update_status("Chargement automatique des donn√©es...")
            self.data_manager = DataManager()
            
            if self.data_manager.get_pr_count() > 0:
                # Mettre √† jour l'interface pour refl√©ter le chargement automatique
                self.data_status.config(text="‚úÖ Donn√©es charg√©es automatiquement")
                self.data_info.config(text=f"{self.data_manager.get_pr_count()} Points de R√©f√©rence disponibles")
                self.generate_btn.config(state='normal')
                self.search_btn.config(state='normal')
                self.add_info(f"‚úÖ {self.data_manager.get_pr_count()} Points de R√©f√©rence charg√©s automatiquement au d√©marrage")
            else:
                self.data_status.config(text="‚ùå Erreur de chargement automatique")
                self.add_info("‚ùå Aucune donn√©e charg√©e automatiquement")
                
        except Exception as e:
            self.data_status.config(text="‚ùå Erreur de chargement automatique")
            self.add_info(f"‚ùå Erreur lors du chargement automatique : {e}")
        finally:
            self.update_status("Pr√™t - Donn√©es charg√©es")
    
    def setup_ui(self) -> None:
        """
        Configure l'interface utilisateur principale.
        """
        # Configuration de la fen√™tre principale
        self.root.title("JBW Viewer - Visualiseur de Points de R√©f√©rence")
        self.root.geometry("600x500")
        self.root.resizable(True, True)
        
        # Style de l'interface
        style = ttk.Style()
        style.theme_use('clam')
        
        # Cr√©er le conteneur principal
        main_frame = ttk.Frame(self.root, padding="10")
        main_frame.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        
        # Titre de l'application
        title_label = ttk.Label(
            main_frame, 
            text="üó∫Ô∏è JBW Viewer", 
            font=('Arial', 16, 'bold')
        )
        title_label.grid(row=0, column=0, columnspan=2, pady=(0, 20))
        
        # Section de chargement des donn√©es
        self.create_data_section(main_frame)
        
        # Section de PR sp√©cifiques
        self.create_specific_pr_section(main_frame)
        
        # Section d'informations
        self.create_info_section(main_frame)
        
        # Boutons d'action
        self.create_action_buttons(main_frame)
        
        # Barre de statut
        self.create_status_bar(main_frame)
    
    def create_data_section(self, parent: ttk.Frame) -> None:
        """
        Cr√©e la section de gestion des donn√©es.
        
        Args:
            parent: Widget parent
        """
        # Frame pour la section donn√©es
        data_frame = ttk.LabelFrame(parent, text="üìä Donn√©es", padding="10")
        data_frame.grid(row=1, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=(0, 10))
        
        # Bouton de rechargement des donn√©es
        self.load_btn = ttk.Button(
            data_frame,
            text="Recharger les donn√©es CSV",
            command=self.load_data
        )
        self.load_btn.grid(row=0, column=0, padx=(0, 10))
        
        # Label de statut des donn√©es
        self.data_status = ttk.Label(data_frame, text="Chargement en cours...")
        self.data_status.grid(row=0, column=1)
        
        # Informations sur les donn√©es
        self.data_info = ttk.Label(data_frame, text="")
        self.data_info.grid(row=1, column=0, columnspan=2, pady=(5, 0))
    
    def create_map_section(self, parent: ttk.Frame) -> None:
        """
        Cr√©e la section de g√©n√©ration de cartes.
        
        Args:
            parent: Widget parent
        """
        # Frame pour la section cartes
        map_frame = ttk.LabelFrame(parent, text="üó∫Ô∏è Cartes", padding="10")
        map_frame.grid(row=2, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=(0, 10))
        
        # Contr√¥les de g√©n√©ration de carte
        controls_frame = ttk.Frame(map_frame)
        controls_frame.grid(row=0, column=0, columnspan=2, sticky=(tk.W, tk.E))
        
        # Limite de marqueurs
        ttk.Label(controls_frame, text="Limite de marqueurs:").grid(row=0, column=0, padx=(0, 5))
        self.max_markers_var = tk.StringVar(value="1000")
        max_markers_entry = ttk.Entry(controls_frame, textvariable=self.max_markers_var, width=10)
        max_markers_entry.grid(row=0, column=1, padx=(0, 20))
        
        # Bouton de g√©n√©ration de carte
        self.generate_btn = ttk.Button(
            controls_frame,
            text="G√©n√©rer la carte",
            command=self.generate_map,
            state='disabled'
        )
        self.generate_btn.grid(row=0, column=2)
        
        # Bouton d'ouverture de la carte
        self.open_btn = ttk.Button(
            controls_frame,
            text="Ouvrir la carte",
            command=self.open_map,
            state='disabled'
        )
        self.open_btn.grid(row=0, column=3, padx=(10, 0))
        
        # Statut de la carte
        self.map_status = ttk.Label(map_frame, text="Aucune carte g√©n√©r√©e")
        self.map_status.grid(row=1, column=0, columnspan=2, pady=(5, 0))
    
    def create_specific_pr_section(self, parent: ttk.Frame) -> None:
        """
        Cr√©e la section pour les PR sp√©cifiques.
        
        Args:
            parent: Widget parent
        """
        # Frame pour la section PR sp√©cifiques
        pr_frame = ttk.LabelFrame(parent, text="üéØ G√©n√©ration de cartes avec PR sp√©cifiques", padding="10")
        pr_frame.grid(row=2, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=(0, 10))
        
        # Zone de saisie des codes PR
        input_frame = ttk.Frame(pr_frame)
        input_frame.grid(row=0, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=(0, 10))
        
        # Titre et options de saisie
        title_frame = ttk.Frame(input_frame)
        title_frame.grid(row=0, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=(0, 5))
        
        ttk.Label(title_frame, text="Codes PR (format: CI-CH, un par ligne):").grid(row=0, column=0, sticky=tk.W)
        
        # Bouton pour charger un fichier
        self.load_file_btn = ttk.Button(
            title_frame,
            text="Charger depuis fichier",
            command=self.load_pr_from_file
        )
        self.load_file_btn.grid(row=0, column=1, padx=(10, 0))
        
        # Zone de texte pour saisir les codes
        self.pr_codes_text = tk.Text(input_frame, height=4, width=50, wrap=tk.WORD)
        self.pr_codes_text.grid(row=1, column=0, sticky=(tk.W, tk.E), pady=(5, 0))
        
        # Scrollbar pour la zone de texte
        pr_scrollbar = ttk.Scrollbar(input_frame, orient=tk.VERTICAL, command=self.pr_codes_text.yview)
        pr_scrollbar.grid(row=1, column=1, sticky=(tk.N, tk.S), pady=(5, 0))
        self.pr_codes_text.configure(yscrollcommand=pr_scrollbar.set)
        
        # Boutons d'action
        button_frame = ttk.Frame(pr_frame)
        button_frame.grid(row=1, column=0, columnspan=2, pady=(10, 0))
        
        # Bouton de g√©n√©ration de carte
        self.generate_btn = ttk.Button(
            button_frame,
            text="G√©n√©rer la carte",
            command=self.generate_specific_map,
            state='disabled'
        )
        self.generate_btn.grid(row=0, column=0, padx=(0, 10))
        
        # Bouton d'ouverture de la carte
        self.open_btn = ttk.Button(
            button_frame,
            text="Ouvrir la carte",
            command=self.open_specific_map,
            state='disabled'
        )
        self.open_btn.grid(row=0, column=1, padx=(0, 10))
        
        # Bouton d'exemple
        self.example_btn = ttk.Button(
            button_frame,
            text="Exemple",
            command=self.load_example_pr
        )
        self.example_btn.grid(row=0, column=2)
        
        # Statut de la carte
        self.map_status = ttk.Label(pr_frame, text="Aucune carte g√©n√©r√©e")
        self.map_status.grid(row=2, column=0, columnspan=2, pady=(5, 0))
    
    def create_info_section(self, parent: ttk.Frame) -> None:
        """
        Cr√©e la section d'informations.
        
        Args:
            parent: Widget parent
        """
        # Frame pour les informations
        info_frame = ttk.LabelFrame(parent, text="‚ÑπÔ∏è Informations", padding="10")
        info_frame.grid(row=3, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=(0, 10))
        
        # Zone de texte pour les informations
        self.info_text = tk.Text(info_frame, height=8, width=70, wrap=tk.WORD)
        self.info_text.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        
        # Scrollbar pour la zone de texte
        scrollbar = ttk.Scrollbar(info_frame, orient=tk.VERTICAL, command=self.info_text.yview)
        scrollbar.grid(row=0, column=1, sticky=(tk.N, tk.S))
        self.info_text.configure(yscrollcommand=scrollbar.set)
        
        # Informations initiales
        self.add_info("Bienvenue dans JBW Viewer !")
        self.add_info("1. Les donn√©es CSV sont charg√©es automatiquement au d√©marrage")
        self.add_info("2. Saisissez des codes PR au format CI-CH (un par ligne)")
        self.add_info("3. Ou chargez un fichier contenant les codes PR")
        self.add_info("4. G√©n√©rez la carte avec les PR s√©lectionn√©s")
        self.add_info("5. Ouvrez la carte dans votre navigateur")
    
    def create_action_buttons(self, parent: ttk.Frame) -> None:
        """
        Cr√©e les boutons d'action principaux.
        
        Args:
            parent: Widget parent
        """
        # Frame pour les boutons
        button_frame = ttk.Frame(parent)
        button_frame.grid(row=5, column=0, columnspan=2, pady=(0, 10))
        
        # Bouton de recherche
        self.search_btn = ttk.Button(
            button_frame,
            text="Rechercher un PR",
            command=self.search_pr,
            state='disabled'
        )
        self.search_btn.grid(row=0, column=0, padx=(0, 10))
        
        # Bouton de quitter
        quit_btn = ttk.Button(
            button_frame,
            text="Quitter",
            command=self.root.quit
        )
        quit_btn.grid(row=0, column=1)
    
    def create_status_bar(self, parent: ttk.Frame) -> None:
        """
        Cr√©e la barre de statut.
        
        Args:
            parent: Widget parent
        """
        self.status_var = tk.StringVar(value="Pr√™t")
        status_label = ttk.Label(parent, textvariable=self.status_var, relief=tk.SUNKEN)
        status_label.grid(row=6, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=(10, 0))
    
    def add_info(self, message: str) -> None:
        """
        Ajoute un message √† la zone d'informations.
        
        Args:
            message (str): Message √† ajouter
        """
        self.info_text.insert(tk.END, f"{message}\n")
        self.info_text.see(tk.END)
    
    def update_status(self, message: str) -> None:
        """
        Met √† jour le message de statut.
        
        Args:
            message (str): Nouveau message de statut
        """
        self.status_var.set(message)
        self.root.update_idletasks()
    
    def load_data(self) -> None:
        """
        Recharge les donn√©es CSV (utilis√© pour le rechargement manuel).
        """
        try:
            self.update_status("Rechargement des donn√©es...")
            self.data_manager = DataManager()
            
            if self.data_manager.get_pr_count() > 0:
                self.data_status.config(text="‚úÖ Donn√©es recharg√©es")
                self.data_info.config(text=f"{self.data_manager.get_pr_count()} Points de R√©f√©rence disponibles")
                self.generate_btn.config(state='normal')
                self.search_btn.config(state='normal')
                self.add_info(f"‚úÖ {self.data_manager.get_pr_count()} Points de R√©f√©rence recharg√©s avec succ√®s")
            else:
                self.data_status.config(text="‚ùå Erreur de rechargement")
                self.add_info("‚ùå Aucune donn√©e recharg√©e")
                
        except Exception as e:
            messagebox.showerror("Erreur", f"Erreur lors du rechargement : {e}")
            self.add_info(f"‚ùå Erreur : {e}")
        finally:
            self.update_status("Pr√™t - Donn√©es recharg√©es")
    
    def generate_map(self) -> None:
        """
        G√©n√®re la carte des Points de R√©f√©rence.
        """
        try:
            if not self.data_manager:
                messagebox.showwarning("Attention", "Veuillez d'abord charger les donn√©es")
                return
            
            self.update_status("G√©n√©ration de la carte...")
            
            # R√©cup√©rer la limite de marqueurs
            try:
                max_markers = int(self.max_markers_var.get())
            except ValueError:
                max_markers = 1000
            
            # Cr√©er le g√©n√©rateur de cartes
            self.map_generator = MapGenerator(self.data_manager)
            
            # G√©n√©rer la carte
            filepath = self.map_generator.generate_complete_map(
                filename="pr_map.html",
                max_markers=max_markers
            )
            
            if filepath:
                self.map_status.config(text=f"‚úÖ Carte g√©n√©r√©e : {os.path.basename(filepath)}")
                self.open_btn.config(state='normal')
                self.add_info(f"‚úÖ Carte g√©n√©r√©e avec succ√®s : {filepath}")
                self.add_info(f"üìç {min(max_markers, self.data_manager.get_pr_count())} marqueurs affich√©s")
            else:
                self.map_status.config(text="‚ùå Erreur de g√©n√©ration")
                self.add_info("‚ùå Erreur lors de la g√©n√©ration de la carte")
                
        except Exception as e:
            messagebox.showerror("Erreur", f"Erreur lors de la g√©n√©ration : {e}")
            self.add_info(f"‚ùå Erreur : {e}")
        finally:
            self.update_status("Pr√™t")
    
    def open_map(self) -> None:
        """
        Ouvre la carte dans le navigateur par d√©faut.
        """
        try:
            if self.map_generator:
                filepath = os.path.join("output", "pr_map.html")
                if os.path.exists(filepath):
                    webbrowser.open(f"file://{os.path.abspath(filepath)}")
                    self.add_info("üåê Carte ouverte dans le navigateur")
                else:
                    messagebox.showwarning("Attention", "Aucune carte g√©n√©r√©e trouv√©e")
            else:
                messagebox.showwarning("Attention", "Veuillez d'abord g√©n√©rer une carte")
        except Exception as e:
            messagebox.showerror("Erreur", f"Erreur lors de l'ouverture : {e}")
    
    def search_pr(self) -> None:
        """
        Ouvre une fen√™tre de recherche de PR.
        """
        if not self.data_manager:
            messagebox.showwarning("Attention", "Veuillez d'abord charger les donn√©es")
            return
        
        # Cr√©er une fen√™tre de recherche
        search_window = tk.Toplevel(self.root)
        search_window.title("Recherche de Points de R√©f√©rence")
        search_window.geometry("400x300")
        
        # Interface de recherche
        ttk.Label(search_window, text="Rechercher un PR").pack(pady=10)
        
        # Champ de recherche
        search_frame = ttk.Frame(search_window)
        search_frame.pack(pady=10)
        
        ttk.Label(search_frame, text="Code CI:").grid(row=0, column=0, padx=(0, 5))
        ci_entry = ttk.Entry(search_frame)
        ci_entry.grid(row=0, column=1, padx=(0, 10))
        
        ttk.Label(search_frame, text="Code CH:").grid(row=0, column=2, padx=(0, 5))
        ch_entry = ttk.Entry(search_frame)
        ch_entry.grid(row=0, column=3)
        
        # Zone de r√©sultats
        results_text = tk.Text(search_window, height=10, width=50)
        results_text.pack(pady=10, padx=10, fill=tk.BOTH, expand=True)
        
        def do_search():
            results_text.delete(1.0, tk.END)
            ci = ci_entry.get().strip()
            ch = ch_entry.get().strip()
            
            if not ci and not ch:
                results_text.insert(tk.END, "Veuillez saisir au moins un code")
                return
            
            results = self.data_manager.search_pr_by_codes(
                codeCI=ci if ci else None,
                codeCH=ch if ch else None
            )
            
            if results:
                results_text.insert(tk.END, f"Trouv√© {len(results)} r√©sultat(s) :\n\n")
                for pr in results[:20]:  # Limiter √† 20 r√©sultats
                    results_text.insert(tk.END, 
                        f"‚Ä¢ {pr['codeCI']}-{pr['codeCH']} : {pr['libelleCI']}\n"
                        f"  Coordonn√©es: X={pr['XLambert93']:.2f}, Y={pr['YLambert93']:.2f}\n\n"
                    )
                if len(results) > 20:
                    results_text.insert(tk.END, f"... et {len(results) - 20} autres r√©sultats")
            else:
                results_text.insert(tk.END, "Aucun r√©sultat trouv√©")
        
        # Bouton de recherche
        ttk.Button(search_window, text="Rechercher", command=do_search).pack(pady=10)
    
    def generate_specific_map(self) -> None:
        """
        G√©n√®re une carte avec des PR sp√©cifiques.
        """
        try:
            if not self.data_manager:
                messagebox.showwarning("Attention", "Veuillez d'abord charger les donn√©es")
                return
            
            # R√©cup√©rer les codes PR saisis
            pr_text = self.pr_codes_text.get("1.0", tk.END).strip()
            if not pr_text:
                messagebox.showwarning("Attention", "Veuillez saisir au moins un code PR")
                return
            
            # Parser les codes PR
            pr_codes = []
            for line in pr_text.split('\n'):
                line = line.strip()
                if line and '-' in line:
                    try:
                        codeCI, codeCH = line.split('-', 1)
                        pr_codes.append((codeCI.strip(), codeCH.strip()))
                    except ValueError:
                        self.add_info(f"‚ö†Ô∏è Format invalide ignor√©: {line}")
                        continue
            
            if not pr_codes:
                messagebox.showwarning("Attention", "Aucun code PR valide trouv√©")
                return
            
            self.update_status("G√©n√©ration de la carte avec PR sp√©cifiques...")
            
            # Cr√©er le g√©n√©rateur de cartes
            self.map_generator = MapGenerator(self.data_manager)
            
            # G√©n√©rer la carte avec les PR sp√©cifiques
            filepath = self.map_generator.generate_map_with_specific_pr(
                pr_codes=pr_codes,
                filename="pr_specific_map.html"
            )
            
            if filepath:
                self.map_status.config(text=f"‚úÖ Carte g√©n√©r√©e : {os.path.basename(filepath)}")
                self.open_btn.config(state='normal')
                self.add_info(f"‚úÖ Carte g√©n√©r√©e avec {len(pr_codes)} PR : {filepath}")
            else:
                self.map_status.config(text="‚ùå Erreur de g√©n√©ration")
                self.add_info("‚ùå Erreur lors de la g√©n√©ration de la carte")
                
        except Exception as e:
            messagebox.showerror("Erreur", f"Erreur lors de la g√©n√©ration : {e}")
            self.add_info(f"‚ùå Erreur : {e}")
        finally:
            self.update_status("Pr√™t")
    
    def open_specific_map(self) -> None:
        """
        Ouvre la carte dans le navigateur.
        """
        try:
            if self.map_generator:
                filepath = os.path.join("output", "pr_specific_map.html")
                if os.path.exists(filepath):
                    webbrowser.open(f"file://{os.path.abspath(filepath)}")
                    self.add_info("üåê Carte ouverte dans le navigateur")
                else:
                    messagebox.showwarning("Attention", "Aucune carte g√©n√©r√©e trouv√©e")
            else:
                messagebox.showwarning("Attention", "Veuillez d'abord g√©n√©rer une carte")
        except Exception as e:
            messagebox.showerror("Erreur", f"Erreur lors de l'ouverture : {e}")
    
    def load_example_pr(self) -> None:
        """
        Charge des exemples de codes PR.
        """
        example_codes = """597120-BA
142091-AO
393314-BV
583005-FP
726158-ST"""
        
        self.pr_codes_text.delete("1.0", tk.END)
        self.pr_codes_text.insert("1.0", example_codes)
        self.add_info("üìù Exemples de codes PR charg√©s")
    
    def load_pr_from_file(self) -> None:
        """
        Charge des codes PR depuis un fichier.
        """
        try:
            # Ouvrir une bo√Æte de dialogue pour s√©lectionner un fichier
            file_path = filedialog.askopenfilename(
                title="S√©lectionner un fichier de codes PR",
                filetypes=[
                    ("Fichiers texte", "*.txt"),
                    ("Fichiers CSV", "*.csv"),
                    ("Tous les fichiers", "*.*")
                ]
            )
            
            if file_path:
                # Lire le fichier
                with open(file_path, 'r', encoding='utf-8') as file:
                    content = file.read().strip()
                
                # Charger le contenu dans la zone de texte
                self.pr_codes_text.delete("1.0", tk.END)
                self.pr_codes_text.insert("1.0", content)
                
                # Compter le nombre de codes
                lines = [line.strip() for line in content.split('\n') if line.strip()]
                valid_codes = [line for line in lines if '-' in line]
                
                self.add_info(f"üìÅ Fichier charg√© : {os.path.basename(file_path)}")
                self.add_info(f"üìä {len(valid_codes)} codes PR valides trouv√©s")
                
        except Exception as e:
            messagebox.showerror("Erreur", f"Erreur lors du chargement du fichier : {e}")
            self.add_info(f"‚ùå Erreur lors du chargement : {e}")
    
    def load_pr_from_file_path(self, file_path: str) -> None:
        """
        Charge des codes PR depuis un fichier fourni en argument.
        
        Args:
            file_path (str): Chemin vers le fichier de codes PR
        """
        try:
            # Lire le fichier
            with open(file_path, 'r', encoding='utf-8') as file:
                content = file.read().strip()
            
            # Charger le contenu dans la zone de texte
            self.pr_codes_text.delete("1.0", tk.END)
            self.pr_codes_text.insert("1.0", content)
            
            # Compter le nombre de codes
            lines = [line.strip() for line in content.split('\n') if line.strip()]
            valid_codes = [line for line in lines if '-' in line]
            
            self.add_info(f"üìÅ Fichier charg√© au d√©marrage : {os.path.basename(file_path)}")
            self.add_info(f"üìä {len(valid_codes)} codes PR valides trouv√©s")
            
        except Exception as e:
            self.add_info(f"‚ùå Erreur lors du chargement du fichier : {e}")
    
    def auto_generate_map(self) -> None:
        """
        G√©n√®re automatiquement la carte avec les PR charg√©s.
        """
        try:
            if not self.data_manager:
                self.add_info("‚ùå Aucune donn√©e disponible pour la g√©n√©ration automatique")
                self.close_application()
                return
            
            # R√©cup√©rer les codes PR saisis
            pr_text = self.pr_codes_text.get("1.0", tk.END).strip()
            if not pr_text:
                self.add_info("‚ùå Aucun code PR saisi pour la g√©n√©ration automatique")
                self.close_application()
                return
            
            # Parser les codes PR avec description optionnelle
            pr_codes = []
            pr_descriptions = {}
            invalid_lines = []
            for line_num, line in enumerate(pr_text.split('\n'), 1):
                line = line.strip()
                if line and '-' in line:
                    try:
                        # S√©parer le code PR de la description (optionnelle)
                        if ';' in line:
                            pr_part, description = line.split(';', 1)
                            description = description.strip()
                        else:
                            pr_part = line
                            description = None
                        
                        # Parser le code PR
                        codeCI, codeCH = pr_part.split('-', 1)
                        codeCI = codeCI.strip()
                        codeCH = codeCH.strip()
                        
                        pr_codes.append((codeCI, codeCH))
                        if description:
                            pr_descriptions[f"{codeCI}-{codeCH}"] = description
                            
                    except ValueError:
                        invalid_lines.append(f"Ligne {line_num}: {line}")
                elif line:  # Ligne non vide mais sans tiret
                    invalid_lines.append(f"Ligne {line_num}: {line}")
            
            if not pr_codes:
                self.add_info("‚ùå Aucun code PR valide trouv√© dans le fichier")
                if invalid_lines:
                    self.add_info("‚ùå Format invalide d√©tect√© :")
                    for invalid in invalid_lines[:5]:  # Limiter √† 5 erreurs
                        self.add_info(f"   - {invalid}")
                self.close_application()
                return
            
            # V√©rifier que les PR existent dans le r√©f√©rentiel
            found_prs = []
            for codeCI, codeCH in pr_codes:
                prs = self.data_manager.search_pr_by_codes(codeCI=codeCI, codeCH=codeCH)
                if prs:
                    found_prs.extend(prs)
            
            if not found_prs:
                self.add_info("‚ùå Aucun PR trouv√© dans le r√©f√©rentiel pour les codes fournis")
                self.add_info(f"‚ùå Codes recherch√©s : {len(pr_codes)} codes")
                self.close_application()
                return
            
            self.update_status("G√©n√©ration automatique de la carte...")
            
            # Cr√©er le g√©n√©rateur de cartes
            self.map_generator = MapGenerator(self.data_manager)
            
            # G√©n√©rer la carte avec les PR sp√©cifiques
            filepath = self.map_generator.generate_map_with_specific_pr(
                pr_codes=pr_codes,
                pr_descriptions=pr_descriptions,
                filename="auto_generated_map.html"
            )
            
            if filepath:
                self.map_status.config(text=f"‚úÖ Carte g√©n√©r√©e automatiquement : {os.path.basename(filepath)}")
                self.open_btn.config(state='normal')
                self.add_info(f"‚úÖ Carte g√©n√©r√©e automatiquement avec {len(found_prs)} PR trouv√©s : {filepath}")
                
                # Ouvrir automatiquement la carte
                self.auto_open_map(filepath)
            else:
                self.map_status.config(text="‚ùå Erreur de g√©n√©ration automatique")
                self.add_info("‚ùå Erreur lors de la g√©n√©ration automatique de la carte")
                self.close_application()
                
        except Exception as e:
            self.add_info(f"‚ùå Erreur lors de la g√©n√©ration automatique : {e}")
            self.close_application()
        finally:
            self.update_status("Pr√™t - Carte g√©n√©r√©e automatiquement")
    
    def auto_open_map(self, filepath: str) -> None:
        """
        Ouvre automatiquement la carte dans le navigateur et ferme l'application.
        
        Args:
            filepath (str): Chemin vers le fichier de carte
        """
        try:
            webbrowser.open(f"file://{os.path.abspath(filepath)}")
            self.add_info("üåê Carte ouverte automatiquement dans le navigateur")
            self.add_info("üîÑ Fermeture de l'application...")
            
            # Fermer l'application apr√®s un court d√©lai
            self.root.after(2000, self.close_application)
            
        except Exception as e:
            self.add_info(f"‚ö†Ô∏è Impossible d'ouvrir automatiquement la carte : {e}")
    
    def close_application(self) -> None:
        """
        Ferme l'application proprement.
        """
        try:
            self.root.quit()
            self.root.destroy()
        except:
            pass
    
    def run(self) -> None:
        """
        Lance l'application.
        """
        self.root.mainloop()


# Test du module si ex√©cut√© directement
if __name__ == "__main__":
    print("üß™ Test du module UI Components")
    
    # Cr√©er et lancer l'interface
    app = JBWViewerUI()
    app.run()
